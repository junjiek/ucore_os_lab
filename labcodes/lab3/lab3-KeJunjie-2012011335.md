# Lab3 实验报告

计24 2012011335 柯均洁

## 练习1：给未被映射的地址映射上物理页

1. 设计实现过程

    > 首先调用`get_pte`函数获取页表项pte。第1、2个参数为当前的页目录`mm->pgdir`以及线性地址`addr`；第3个参数`create`设为1，表示如果该页表未存在则创建新的页表。

    > 若ptep所指向的内容为空，说明对应的物理地址不存在，调用`pgdir_alloc_page`函数在内存中分配一个页帧，并建立逻辑地址和物理地址的映射。

    > 若ptep所指向的内容不为空，说明对应的物理地址存在，page fault产生的原因是对应的物理页帧被swap到外存上。如果swap已经被初始化过，则调用`swap_in`函数将外存中对应的内容调入page管理的物理页帧中，调用`page_insert`函数建立物理地址和逻辑地址的映射，并将page放入swappable pages里面。

2. 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。

    > PDE 和 PTE 中的 PTE\_A （访问位）表示该项最近是否被访问过，PTE\_D （修改位）表示该项是否被修改过。在页替换算法过程中，需要根据这些标志位来判断替换的顺序等策略。

3. 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
    > 硬件需要在发生异常时保存寄存器的值和堆栈状态等运行信息，供之后返回时使用；然后转到异常处理代码入口交给操作系统的页访问异常程序处理；处理完毕后，恢复现场继续执行即可。

## 练习2：补充完成基于FIFO的页面替换算法

1. 设计实现过程

    > 对于新加入的swappable pages，调用`list_add`函数将该新的entry插入到列表的前端。

    > 对于swap out操作，首先调用`list_prev`获取位于链表末端项，然后调用`list_del`函数将该entry从链表中删除，并将`ptr_page`指向的内容赋为被换出的page。

2. 如果要在ucore上实现"extended clock页替换算法"请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题
    - 需要被换出的页的特征是什么？
        > 当前指针所第一个扫描到的访问位和修改位同时为零的项。
    - 在ucore中如何判断具有这样特征的页？
        > 通过swap_manager维护一个页的链表和指针，用指针循着链表进行扫描。
    - 何时进行换入和换出操作？
        > 产生缺页异常且该页位于外存中。

## 和参考答案的区别

实现基本和参考答案基本一致，只是一些语句的表达上存在不同。开始时我没有对函数的返回值进行判断，比如判断ptep是否为空，以及swap_in的返回值是否为零等等。在对照了参考答案之后进行了相应修改。

## 知识点

1. 虚拟存储的实现方式和二级页表的大致框架
2. 如何判断、处理页缺失异常。首先是判断读写权限是否一致，然后判断对应页是否在外存中（根据页表项的内容是否为空）。如果页不存在则分配一个页并且建立映射关系，如果位于外存中则从外存调入，建立映射关系，并将该页加入swappable链表。
3. 页置换算法FIFO的具体实现。基本思想是维护一个链表，来表示页进入内存的先后顺序。

原理课中比较重要的知识点还有全局页面置换算法，包括缺页率置换算法和工作集置换算法等，在此次l实验中没有体现。
