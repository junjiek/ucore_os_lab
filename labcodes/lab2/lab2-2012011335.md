# Lab2 report

柯均洁 计24 2012011335

## 练习1：实现 first-fit 连续物理内存分配算法

1. first-fit 设计实现过程
    > 我在代码中实现了两个版本，改进前的 Version 0 以注释的方式呈现，以下主要讨论改进前代码的实现方式：
    > Version 0:
    > 在函数`default_init_memmap`中对所有页进行初始化，将当前的以 `base` 作为基址长度为 `n` 的页按顺序加入链表，并将flags和ref清零，设定好`property` 值（除了 base 为 n 之外其他页都为 0 ）。同时还要更新`nr_free`，用以记录内存中可用页的数量。

    > 在函数`default_alloc_pages`中，先对`free_list`进行线性扫描，找到第一个大小大于 n 的 block ，如果遍历完还找不到，则分配失败。若能找到，则逐一将该页后面的 n 个页面移出`free_list`并 set reserved 及 clear page property。如果分配完 n 个页面还剩下空闲页面的话，则将这部分空闲页面的第一个 Page 的 property 设置为原结点的 property - n，表示该block剩下的页数。

    > 在函数`default_free_pages`中，首先将base后的n个页面释放，然后对空闲列表进行线性扫描，找到插入的位置（第一个地址大于base的），然后看看前后的空闲块是否相邻，如果相邻则将他们合并起来，即调整它们最前面的块的 property，这样就完成了空闲块的合并。

2. 是否有改进空间？
    > Version 0 有改进空间，现在在链表 `free_list` 存了每一个 free 的页，但很多页面 property 域 0 ，没有实际的作用，增加了遍历的开销。事实上，`free_list` 可以只存储每个空闲区域的头一个 Page ，这样可以减少遍历链表的时间。
    > 根据这个改进思路，我编写了新的改进版的first-fit代码，在 Improved Version 下面

## 练习2：实现寻找虚拟地址对应的页表项

0. 实现思路

    > 使用提示中的PDX取出la的前10位，作为索引在pgdir目录中找到对应PDE项
    > 通过PDE中的标志位来判断该PDE是否合法，如果非法而且需要create，那么我们需要对所请求的页表进行创建。
    > 创建新的页时调用`alloc_page`函数分配一个新的页，作为二级页表的存储空间。把该页的内容清零，设置PDE中的标志位。
    > 最后返回所请求的二级页表的内容PTE。

1. 请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。

    > * 页目录项PDE为32位，前20位为对应页表的基地址，后12位包含了一些该PDE项的属性信息，比如保留位、访问位、可写位、权限位等等。通过PDE中的基地址加上虚拟地址中提供的二级页表索引便可以访问到页表项的内容。合法标志位可以方便操作系统对二级页表进行管理。
    > * 页表项PTE为32位，前20位对应物理内存的基地址，后12位包含了一些该PTE项的属性信息，比如保留位、访问位、可写位、权限位等等。通过PTE中的物理内存基地址加上虚拟地址中的页内偏移便可以访问物理内存的内容。

2. 如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

    > 出现页访问异常时，硬件MMU会触发page fault异常，交由操作系统处理，等待操作系统执行页置换算法之后将所请求的页从外存载入。

## 练习3：释放某虚地址所在的页并取消对应二级页表项的映射

0. 实现思路

    > 首先通过标志位判断该PTE是否合法

    > 若合法，则找到PTE所指向的页，然后将该页的引用数减1。若引用数减至0，则说明此时没有程序使用该页的内容，需要将该页释放。

    > 通过设置标志位将PTE设置为非法，最后从TLB中将该项清除。

1. 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

    > 数据结构Page的全局变量数组里的就是页目录表和页表指向的物理页，未分配的Page与表项无对应关系，已分配的Page地址的前20位与某些页表项的前20位相等。页的虚拟地址转换需要通过页表来实现。

2. 如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题

    > 在段机制中采用对等映射来使得虚拟地址与物理地址相等。具体地说，在entry.S中取消段偏移，并在boot_map_segment函数中将映射方法实现为对等映射。
