# Lab7 实验报告

2012011335 柯均洁 计24 kjj3300@163.com

## 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）

1. 请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。

    在内核级信号量`semaphore_t`结构中，`value`为信号量的当前值，`wait_queue`为该信号量对应的等待队列。

    信号量`semaphore_t`中`down`和`up`两个函数分别对应信号量的P操作和V操作。

    当内核线程对某一信号量执行P操作时，该线程调用信号量的`down`函数。`down`函数的执行过程如下：
    
    - 先关闭中断，进入临界区。
    - 接着检查信号量值，如果`value`大于0，则`value`减1，恢复中断并返回0。
    - 如果`value`为0，说明此时没有足够的信号量可以使用，那么这时该内核线程被加入信号量的等待队列中，恢复中断，并调用`schedule`函数调度下一个就绪的函数。
    - 在该线程被唤醒之后，先关闭中断，然后将自己从信号量等待队列中删除，并判断被唤醒的标记是否与之前等待的标记相同，如果正常的话，返回0。

    当内核线程对某一信号量执行V操作时，该线程调用信号量的`up`函数。`up`函数的执行过程如下：

    - 先关闭中断，进入临界区。
    - 接着检查信号量的等待队列是否为空。如果为空，那么直接将信号量的`value`加1，返回。
    - 如果不为空，那么从信号量的等待队列中选择一个进程，唤醒该进程，返回。

2. 请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

    由于用户态进程运行在用户态权限，没有办法直接关闭中断。此时，操作系统应该把对信号量的创建及相应的P/V操作进行封装，给用户态程序提供系统调用。用户态的应用程序可以向操作系统内核申请一个信号量，并通过系统调用对其进行P操作和V操作。

    相同点：采用了一样的信号量机制，都是通过P/V操作对信号量管理的资源进行操作，从而实现同步互斥。

    不同点：用户态的进程需要通过操作系统提供的系统调用来完成信号量操作，在进行信号量操作的时候，需要进行用户态和内核态的切换。

## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）

1. 请在实验报告中给出内核级条件变量的设计描述，并说其大致执行流流程。

```
    cond_signal(cv) {
        if(cv.count > 0) {
            mt.next_count ++;
            signal(cv.sem);
            wait(mt.next);
            mt.next_count--;
        }
    }
```

`cond_signal`函数：首先判断`cv.count`，如果不大于0，则表示当前没有执行`cond_wait`而睡眠的进程，因此就没有被唤醒的对象了，直接返回；如果大于0，则需要唤醒等待在`cv.sem`上的进程A。由于只允许一个进程在管程中执行，所以当前进程需要睡在信号量`monitor.next`上，同时`monitor.next_count`加一。睡醒之后，再让`monitor.next_count`减一。

```
    cond_wait(cv) {
        cv.count ++;
        if(mt.next_count>0)
           signal(mt.next)
        else
           signal(mt.mutex);
        wait(cv.sem);
        cv.count --;
    }
```

`cond_wait`函数：首先，当前等待该条件的进程个数`cv.count`加一。如果`next_count`大于0，说明有大于等于1个进程执行`cond_signal`且睡着了，所以唤醒`mtp.next`。如果`next_count`小于等于0，表示目前没有进程因为执行`cond_signal`函数而睡眠，需要唤醒的是进入临界区的进程，因此唤醒睡在`monitor.mutex`上的进程。然后进程A睡在`cv.sem`上，如果睡醒了，则让`cv.count`减一，表示等待此条件的睡眠进程个数少了一个，可继续执行了。

`phi_take_forks_condvar`函数：首先将哲学家i状态设置为HUNGRY，然后检测是否满足他吃东西的条件，如果不满足的话一直对条件变量进行wait操作。

`phi_put_forks_condvar`函数：在哲学家放下筷子时，将他的状态设置为THINKING，然后检查它左右两个人的状态。

3. 请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。

    条件变量的实现依赖于信号量，所以在用户态进程实现条件变量机制需要有用户态进程的信号量机制作为基础。练习1中已指出，可以通过操作系统提供系统调用实现用户态信号量机制。在此基础上，可以进一步对`cond_wait`和`cond_signal`两个函数进行封装，提供条件变量的系统调用。

## 与参考答案的区别

思路与注释一致，在具体代码上与参考答案略有区别

## 知识点

1. 同步互斥的框架
2. 信号量、管程、条件变量的原理及实现
3. 哲学家问题

实验的实现与原理课上讲解的内容存在细节上的差异。例如，条件变量的计数，在原理课中是在wait和signal两个函数中分别进行，而在实验中是在一个函数中完成。

