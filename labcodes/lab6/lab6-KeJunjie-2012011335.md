# Lab6 实验报告

2012011335 柯均洁 计24 kjj3300@163.com

## 练习1: 使用 Round Robin 调度算法（不需要编码）

1. 请理解并分析sched_calss中各个函数指针的用法，并接合Round Robin 调度算法描ucore的调度执行过程

    - `init`函数：初始化进程调度队列，将队列置为空
    - `enqueue`函数：往进程调度队列中加入一个进程
    - `dequeue`函数：从进程调度队列中删除一个进程
    - `pick_next`函数：从进程调度队列中选取下一个执行的进程
    - `proc_tick`函数：在产生时钟中断的时候处理进程调度，对进程调度队列进行管理和更新。

    当产生时钟中断时`proc_tick`被调用，当前进程的`time_slice`就会减1。如果当前进程的`time_slice`大于0，则继续执行当前进程，不需要重新调度。如果当前进程的`time_slice`为0，则当前进程的时间片已用完，调度算法将其的`need_resched`标记为1，表明当前进程需要被重新调度。当产生时钟中断或者其他异常的时候，操作系统会判断当前进程的`need_resched`标志，如果为1则调用`schedule`函数来启用调度算法。调度算法先判断当前进程是否为就绪状态，如果是的话将其加入进程调度队列。接着，调度算法从进程队列中挑选出一个进程作为下一个被执行的进程，调度完成。

    RR算法中，所有就绪进程组织成一个链表，调度算法会把队列末端的进程作为下一个被执行的进程。

2. 请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计

    1. 维护多条不同优先级的队列，假设队列q1有最高优先级，qn优先级最低。调度时优先调度高优先级队列。
    2. 当新进程生成并加入队列时，将它加入q1
    3. 进程控制块记录该进程的所属队列，当进程用尽时间片时，它的优先级降低，将其插入低一级的队列的队尾
    4. 不同优先级队列时间片长度不同，长度随优先级递减

## 练习2: 实现 Stride Scheduling 调度算法（需要编码）

1. 设计实现过程

    首先将BIG_STRIDE设置为一个很大的整数。由于所有跟优先级相关的变量都被设置成32位无符号整数，此处我们将BIG_STRIDE定义为0xfffffff.

    `stride_init`函数中，首先对run_list链表进行初始化，接着对lab6_run_pool进行初始化设置为空指针，进程数量proc_num设置为零。

    `enqueue`函数中，调用skew_heap_insert将当前进程加入就绪进程队列中，将当前进程的可用时间片值设置为max_time_slice，将当前进程的调度队列rq进行设置，计数器proc_num的值加1。

    `dequeue`函数中，调用skew_heap_remove函数删除就绪进程队列中的一个进程，计数器proc_num减一。

    `pick_next`函数中，先判断调度队列是否为空，如果为空则直接返回空指针。如果调度队列不为空，我们取出队列首部的进程，然后修改该进程的stride值，加上该进程将会执行的pass的值。公式为 pass = BIG_STRIDE / priority。

    `proc_tick`函数中，将当前进程的time_slice减1，若减至0那么说明当前进程需要被调度，设置`need_resched`为1。


## 与参考答案的区别

基本思路一致，具体实现略有区别。例如，调度队列是否为空用了`proc_num == 0`；在proc_tick函数中，我采取了更加简洁的实现：

```c
    if (!(--proc->time_slice)) {
            proc->need_resched = 1;
    }
```

## 知识点

1. stride算法的实现
2. schedule框架
3. 整个进程调度流程

我认为原理课中比较重要的知识点还有其他调度算法，包括多级反馈队列等高级算法。
